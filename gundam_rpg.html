<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gundam RPG - Tactical Battle</title>
    <style>
        @font-face {
            font-family: 'font';
            src: url('asset/Menu/font.otf') format('opentype');
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: Arial, sans-serif;
        }

        #gameContainer {
            display: flex;
            width: 1400px;
            height: 800px;
            background: #0f3460;
            border: 3px solid #00d4ff;
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.5);
            border-radius: 10px;
            overflow: hidden;
        }

        #battleArea {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: linear-gradient(180deg, #1a3a52 0%, #0d1f2d 100%);
            border-right: 2px solid #00d4ff;
        }

        #mapGrid {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 1px;
            padding: 10px;
            background: #0a1f2e;
            background-size: cover;
            background-position: center;
            position: relative;
        }

        .gridCell {
            background: rgba(26, 77, 109, 0.3);
            border: 2px solid #00d4ff;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            z-index: 1;
        }

        .gridCell:hover {
            background: #2a6d8d;
            box-shadow: inset 0 0 10px rgba(0, 212, 255, 0.3);
        }

        .gridCell.walkable {
            background: rgba(42, 93, 77, 0.5);
        }

        .gridCell.attackable {
            background: rgba(93, 42, 42, 0.5);
        }

        .gridCell.selected {
            background: rgba(0, 212, 255, 0.6);
            box-shadow: inset 0 0 15px rgba(0, 212, 255, 0.8);
        }

        .unit {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 24px;
            cursor: pointer;
            user-select: none;
            position: relative;
            z-index: 2;
        }

        .unit.gundam {
            background: linear-gradient(135deg, #0064ff 0%, #004db3 100%);
            color: #ffff00;
        }

        .unit.zaku {
            background: linear-gradient(135deg, #ff0000 0%, #cc0000 100%);
            color: #ffffff;
        }

        .unit.friendly {
            border: 3px solid #00ff00;
        }

        .unit.enemy {
            border: 3px solid #ff0000;
        }

        .unit img {
            width: 80%;
            height: 80%;
            object-fit: contain;
        }

        #sidebar {
            width: 350px;
            background: linear-gradient(180deg, #1a1a2e 0%, #0f3460 100%);
            border-left: 2px solid #00d4ff;
            display: flex;
            flex-direction: column;
            padding: 15px;
            color: #00d4ff;
            overflow-y: auto;
        }

        #sidebarTitle {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 2px solid #00d4ff;
            padding-bottom: 10px;
        }

        .unitPanel {
            background: rgba(0, 212, 255, 0.1);
            border: 2px solid #00d4ff;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .unitPanel h3 {
            color: #ffff00;
            margin-bottom: 8px;
        }

        .stat {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            font-size: 13px;
        }

        .statBar {
            display: flex;
            align-items: center;
            margin: 6px 0;
            font-size: 12px;
        }

        .statBar span:first-child {
            width: 50px;
        }

        .hpBar {
            flex: 1;
            height: 12px;
            background: #333;
            border: 1px solid #00d4ff;
            border-radius: 2px;
            margin: 0 8px;
            overflow: hidden;
        }

        .hpBarFill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00 0%, #ffff00 50%, #ff6b00 100%);
            transition: width 0.3s;
        }

        #actions {
            margin-top: 15px;
            border-top: 2px solid #00d4ff;
            padding-top: 15px;
        }

        .actionBtn {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: rgba(0, 212, 255, 0.2);
            border: 2px solid #00d4ff;
            color: #00d4ff;
            font-weight: bold;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.3s;
            font-size: 12px;
        }

        .actionBtn:hover {
            background: rgba(0, 212, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        .actionBtn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #turnInfo {
            background: rgba(0, 212, 255, 0.1);
            border: 2px solid #00d4ff;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 15px;
            text-align: center;
            font-weight: bold;
            font-size: 14px;
        }

        #battleLog {
            flex: 1;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #00d4ff;
            border-radius: 3px;
            padding: 10px;
            overflow-y: auto;
            font-size: 11px;
            line-height: 1.3;
        }

        .logEntry {
            color: #00d4ff;
            margin: 2px 0;
            padding: 2px;
        }

        .logEntry.damage {
            color: #ff6b6b;
        }

        .logEntry.heal {
            color: #51cf66;
        }

        .logEntry.info {
            color: #ffd43b;
        }

        .logEntry.enemy {
            color: #ff99cc;
        }

        #gameOver {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: #00d4ff;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            z-index: 100;
            display: none;
            border: 3px solid #00d4ff;
            min-width: 400px;
        }

        #gameOver h1 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #ffff00;
        }

        #gameOver p {
            font-size: 18px;
            margin: 10px 0;
        }

        #gameOver button {
            background: #00d4ff;
            color: #000;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 20px;
        }

        #gameOver button:hover {
            background: #ffff00;
        }

        .headerBar {
            background: linear-gradient(90deg, #00d4ff 0%, #004d99 100%);
            color: #000;
            padding: 8px;
            font-weight: bold;
            text-align: center;
        }

        .movementStatus {
            font-size: 12px;
            color: #51cf66;
            margin-top: 5px;
        }

        .movementStatus.acted {
            color: #ff6b6b;
        }

        #menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        #menuTitle {
            width: 400px;
            height: auto;
            object-fit: contain;
            margin-bottom: 40px;
        }

        .menuImage {
            position: fixed;
            height: 100vh;
            width: 300px;
            object-fit: cover;
            top: 0;
        }

        .menuImage.left {
            left: 0;
        }

        .menuImage.right {
            right: 0;
        }

        #pressEnter {
            font-family: 'font', Arial, sans-serif;
            font-size: 28px;
            color: #00d4ff;
            font-weight: bold;
            animation: blink 1s infinite;
            margin-top: 20px;
        }

        @keyframes blink {
            0%, 49% {
                opacity: 1;
            }
            50%, 100% {
                opacity: 0;
            }
        }

        body.hideMenu #gameContainer,
        body.hideMenu #gameOver {
            display: flex !important;
        }

        #menuMusic {
            display: none;
        }

        #cinematicContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 150;
        }

        #cinematicVideo {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        #stageScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 150;
        }

        #stageText {
            font-family: 'font', Arial, sans-serif;
            font-size: 80px;
            color: #00d4ff;
            font-weight: bold;
            text-align: center;
        }
    </style>
</head>
<body>
    <audio id="menuMusic" autoplay loop muted>
        <source src="asset/Menu/mainmusique.mp3" type="audio/mpeg">
    </audio>

    <audio id="fightMusic" loop>
        <source src="asset/Menu/fight.mp3" type="audio/mpeg">
    </audio>

    <div id="menu">
        <img class="menuImage left" src="asset/Menu/menu2.png" alt="Menu Left">
        <img class="menuImage right" src="asset/Menu/menu1.png" alt="Menu Right">
        <img id="menuTitle" src="asset/Menu/title.png" alt="Title">
        <div id="pressEnter">PRESS ENTER</div>
    </div>

    <div id="cinematicContainer">
        <video id="cinematicVideo" controls>
            <source src="asset/Menu/stage1.mp4" type="video/mp4">
        </video>
    </div>

    <div id="stageScreen">
        <div id="stageText">STAGE 1</div>
    </div>

    <div id="gameContainer" style="display: none;">
        <div id="battleArea">
            <div class="headerBar">GRILLE DE COMBAT</div>
            <div id="mapGrid"></div>
        </div>
        <div id="sidebar">
            <div id="sidebarTitle">INFOS</div>
            <div id="turnInfo">
                <div>Tour: <span id="turnNumber">1</span></div>
                <div id="currentPlayer"></div>
            </div>
            <div id="selectedUnitInfo"></div>
            <div id="actions"></div>
            <div id="battleLog"></div>
        </div>
    </div>

    <div id="gameOver">
        <h1 id="gameOverTitle">VICTOIRE!</h1>
        <p id="gameOverMsg"></p>
        <button onclick="location.reload()">Recommencer</button>
    </div>

    <script>
        let gameStarted = false;

        function startCinematic() {
            const menu = document.getElementById('menu');
            const cinematicContainer = document.getElementById('cinematicContainer');
            const menuMusic = document.getElementById('menuMusic');
            
            menu.style.display = 'none';
            cinematicContainer.style.display = 'flex';
            menuMusic.pause();

            const video = document.getElementById('cinematicVideo');
            video.currentTime = 0;
            video.play();

            video.addEventListener('ended', showStageScreen, { once: true });
        }

        function showStageScreen() {
            const cinematicContainer = document.getElementById('cinematicContainer');
            const stageScreen = document.getElementById('stageScreen');
            
            cinematicContainer.style.display = 'none';
            stageScreen.style.display = 'flex';

            setTimeout(() => {
                startGame();
            }, 3000);
        }

        function startGame() {
            if (gameStarted) return;
            gameStarted = true;
            
            const stageScreen = document.getElementById('stageScreen');
            const gameContainer = document.getElementById('gameContainer');
            const menuMusic = document.getElementById('menuMusic');
            const fightMusic = document.getElementById('fightMusic');
            
            stageScreen.style.display = 'none';
            gameContainer.style.display = 'flex';
            
            menuMusic.pause();
            fightMusic.currentTime = 0;
            fightMusic.play().catch(() => {
                console.log('Fight music autoplay blocked');
            });
            
            initializeGame();
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !gameStarted) {
                startCinematic();
            }
        });

        window.addEventListener('load', () => {
            const menuMusic = document.getElementById('menuMusic');
            menuMusic.muted = false;
            menuMusic.currentTime = 0;
            menuMusic.play().catch(() => {
                console.log('Menu music autoplay blocked - user interaction may be required');
            });

            const fightMusic = document.getElementById('fightMusic');
            fightMusic.addEventListener('ended', () => {
                if (gameStarted && !document.getElementById('gameOver').style.display || document.getElementById('gameOver').style.display === 'none') {
                    fightMusic.currentTime = 0;
                    fightMusic.play();
                }
            });
        });

        const GRID_WIDTH = 10;
        const GRID_HEIGHT = 8;

        class Unit {
            constructor(id, name, type, team, x, y, stats) {
                this.id = id;
                this.name = name;
                this.type = type;
                this.team = team;
                this.x = x;
                this.y = y;
                this.stats = stats;
                this.hp = stats.maxHp;
                this.moved = false;
                this.acted = false;
            }

            isAlive() {
                return this.hp > 0;
            }

            takeDamage(damage) {
                this.hp = Math.max(0, this.hp - damage);
            }

            resetTurn() {
                this.moved = false;
                this.acted = false;
            }

            getMovementRange() {
                return this.stats.mov;
            }

            getWeaponRange() {
                return this.stats.weaponRange || 1;
            }
        }

        const gameState = {
            units: [],
            turn: 1,
            currentTeam: 'player',
            selectedUnit: null,
            battleLog: [],
            gameEnded: false,
            lastMoveDirection: null,
            gundamBetaLastDirection: null,
        };

        function initializeGame() {
            gameState.units.push(
                new Unit('player1', 'Gundam Alpha', 'gundam', 'player', 1, 1, {
                    maxHp: 80, atk: 18, def: 12, spd: 14, mov: 5, weaponRange: 1
                }),
                new Unit('player2', 'Gundam Beta', 'gundam', 'player', 3, 0, {
                    maxHp: 75, atk: 16, def: 10, spd: 16, mov: 5, weaponRange: 1
                })
            );

            gameState.units.push(
                new Unit('enemy1', 'Zaku Red', 'zaku', 'enemy', 8, 1, {
                    maxHp: 70, atk: 16, def: 11, spd: 12, mov: 5, weaponRange: 1
                }),
                new Unit('enemy2', 'Zaku Green', 'zaku', 'enemy', 6, 7, {
                    maxHp: 70, atk: 16, def: 11, spd: 12, mov: 5, weaponRange: 1
                })
            );

            const mapGrid = document.getElementById('mapGrid');
            const timestamp = new Date().getTime();
            mapGrid.style.backgroundImage = `url('asset/map/map1.png?t=${timestamp}')`;
            
            renderMap();
            updateUI();
        }

        function renderMap() {
            const mapGrid = document.getElementById('mapGrid');
            mapGrid.innerHTML = '';

            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'gridCell';
                    cell.id = `cell-${x}-${y}`;
                    cell.onclick = () => handleCellClick(x, y);

                    const unit = gameState.units.find(u => u.x === x && u.y === y);
                    if (unit) {
                        const unitDiv = document.createElement('div');
                        unitDiv.className = `unit ${unit.type} ${unit.team === 'player' ? 'friendly' : 'enemy'}`;
                        
                        if (unit.id === 'player2') {
                            const assetPath = getGundamZetaAsset(unit);
                            const img = document.createElement('img');
                            img.src = assetPath;
                            img.alt = unit.name;
                            unitDiv.appendChild(img);
                        } else {
                            unitDiv.textContent = unit.type === 'gundam' ? 'ðŸ¤–' : 'ðŸ‘¾';
                        }
                        
                        cell.appendChild(unitDiv);
                    }

                    mapGrid.appendChild(cell);
                }
            }

            highlightMovement();
        }

        function getGundamZetaAsset(unit) {
            const baseDir = 'asset/Joueur/GundamZeta/';
            
            if (unit === gameState.selectedUnit && gameState.selectedUnit.team === 'player') {
                if (gameState.lastMoveDirection === 'right') {
                    return baseDir + 'GundamZetaDD.png';
                } else if (gameState.lastMoveDirection === 'left') {
                    return baseDir + 'GundamZetaDG.png';
                } else if (gameState.lastMoveDirection === 'down') {
                    return baseDir + 'GundamZetaDB.png';
                } else if (gameState.lastMoveDirection === 'up') {
                    return baseDir + 'GundamZetaDH.png';
                }
                return baseDir + 'GundamZetaB.png';
            }
            
            if (gameState.gundamBetaLastDirection === 'right') {
                return baseDir + 'GundamZetaND.png';
            } else if (gameState.gundamBetaLastDirection === 'left') {
                return baseDir + 'GundamZetaNG.png';
            }
            return baseDir + 'GundamZetaN.png';
        }

        function highlightMovement() {
            document.querySelectorAll('.gridCell').forEach(cell => {
                cell.classList.remove('walkable', 'attackable', 'selected');
            });

            if (!gameState.selectedUnit) return;

            const unit = gameState.selectedUnit;
            if (!unit.acted) {
                const walkable = getWalkableTiles(unit);
                walkable.forEach(pos => {
                    if (gameState.units.find(u => u.x === pos.x && u.y === pos.y)) return;
                    const cell = document.getElementById(`cell-${pos.x}-${pos.y}`);
                    if (cell) cell.classList.add('walkable');
                });
            }

            if (!unit.acted) {
                const attackable = getAttackableTiles(unit);
                attackable.forEach(pos => {
                    const cell = document.getElementById(`cell-${pos.x}-${pos.y}`);
                    if (cell) cell.classList.add('attackable');
                });
            }

            const selectedCell = document.getElementById(`cell-${unit.x}-${unit.y}`);
            if (selectedCell) selectedCell.classList.add('selected');
        }

        function getWalkableTiles(unit) {
            const walkable = [];
            const visited = new Set();
            const queue = [{ x: unit.x, y: unit.y, dist: 0 }];

            while (queue.length > 0) {
                const { x, y, dist } = queue.shift();
                const key = `${x},${y}`;

                if (visited.has(key)) continue;
                visited.add(key);

                if (dist > 0) walkable.push({ x, y });
                if (dist >= unit.getMovementRange()) continue;

                const neighbors = [
                    { x: x + 1, y },
                    { x: x - 1, y },
                    { x, y: y + 1 },
                    { x, y: y - 1 },
                ];

                neighbors.forEach(n => {
                    if (n.x >= 0 && n.x < GRID_WIDTH && n.y >= 0 && n.y < GRID_HEIGHT) {
                        // Ignore les autres unitÃ©s du joueur, bloque les ennemis
                        const blocked = gameState.units.some(u => 
                            u.x === n.x && u.y === n.y && u.id !== unit.id && u.team === 'enemy'
                        );
                        if (!blocked) queue.push({ x: n.x, y: n.y, dist: dist + 1 });
                    }
                });
            }

            return walkable;
        }

        function getAttackableTiles(unit) {
            const attackable = [];
            const range = unit.getWeaponRange();

            for (let x = Math.max(0, unit.x - range); x <= Math.min(GRID_WIDTH - 1, unit.x + range); x++) {
                for (let y = Math.max(0, unit.y - range); y <= Math.min(GRID_HEIGHT - 1, unit.y + range); y++) {
                    const dist = Math.abs(x - unit.x) + Math.abs(y - unit.y);
                    if (dist > 0 && dist <= range) {
                        attackable.push({ x, y });
                    }
                }
            }

            return attackable;
        }

        function updateUI() {
            const selected = gameState.selectedUnit;
            const infoDiv = document.getElementById('selectedUnitInfo');
            const actionsDiv = document.getElementById('actions');
            const turnDiv = document.getElementById('currentPlayer');
            const turnNum = document.getElementById('turnNumber');

            turnDiv.textContent = gameState.currentTeam === 'player' ? 'Phase: JOUEUR' : 'Phase: ENNEMI';
            turnNum.textContent = gameState.turn;

            if (selected) {
                const hpPercent = (selected.hp / selected.stats.maxHp) * 100;
                const movedStatus = selected.moved ? 'âœ“' : 'âœ—';
                const actedStatus = selected.acted ? 'âœ“' : 'âœ—';

                infoDiv.innerHTML = `
                    <div class="unitPanel">
                        <h3>${selected.name}</h3>
                        <div class="stat">
                            <span>Ã‰quipe:</span>
                            <span>${selected.team === 'player' ? 'JOUEUR' : 'ENNEMI'}</span>
                        </div>
                        <div class="stat">
                            <span>Position:</span>
                            <span>(${selected.x}, ${selected.y})</span>
                        </div>
                        <div class="statBar">
                            <span>PV:</span>
                            <div class="hpBar">
                                <div class="hpBarFill" style="width: ${hpPercent}%"></div>
                            </div>
                            <span>${selected.hp}/${selected.stats.maxHp}</span>
                        </div>
                        <div class="stat">
                            <span>ATK:</span>
                            <span>${selected.stats.atk}</span>
                        </div>
                        <div class="stat">
                            <span>DEF:</span>
                            <span>${selected.stats.def}</span>
                        </div>
                        <div class="stat">
                            <span>VIT:</span>
                            <span>${selected.stats.spd}</span>
                        </div>
                        <div class="stat">
                            <span>MOV:</span>
                            <span>${selected.stats.mov}</span>
                        </div>
                        ${selected.team === 'player' ? `<div class="movementStatus ${selected.moved && selected.acted ? 'acted' : ''}">
                            DÃ©placement: - | Action: ${actedStatus}
                        </div>` : ''}
                    </div>
                `;

                if (selected.team === 'player') {
                    actionsDiv.innerHTML = `
                        <button class="actionBtn" onclick="moveUnit()" ${selected.acted ? 'disabled' : ''}>
                            âž¤ DÃ©placer
                        </button>
                        <button class="actionBtn" onclick="attackMode()" ${selected.acted ? 'disabled' : ''}>
                            âš” Attaquer
                        </button>
                        <button class="actionBtn" onclick="skipAction()" ${selected.acted ? 'disabled' : ''}>
                            âŠ˜ Passer
                        </button>
                        <button class="actionBtn" onclick="selectNextUnit()">
                            âžœ UnitÃ© Suivante
                        </button>
                        <button class="actionBtn" onclick="endPlayerTurn()">
                            âœ“ Fin du Tour
                        </button>
                    `;
                } else {
                    actionsDiv.innerHTML = '';
                }
            } else {
                infoDiv.innerHTML = '<div style="color: #888; padding: 10px;">Cliquez sur une unitÃ©</div>';
                actionsDiv.innerHTML = '';
            }
        }

        function handleCellClick(x, y) {
            if (gameState.gameEnded || gameState.currentTeam !== 'player') return;

            const clickedUnit = gameState.units.find(u => u.x === x && u.y === y);

            if (clickedUnit) {
                if (clickedUnit.team === 'player' && clickedUnit.id !== gameState.selectedUnit?.id) {
                    gameState.selectedUnit = clickedUnit;
                    gameState.lastMoveDirection = null;
                    renderMap();
                    updateUI();
                } else if (clickedUnit.team === 'enemy') {
                    gameState.selectedUnit = clickedUnit;
                    updateUI();
                }
                return;
            }

            if (!gameState.selectedUnit || gameState.selectedUnit.team !== 'player' || gameState.selectedUnit.acted) return;

            const walkable = getWalkableTiles(gameState.selectedUnit);
            const isWalkable = walkable.some(w => w.x === x && w.y === y);

            if (isWalkable) {
                const oldX = gameState.selectedUnit.x;
                const oldY = gameState.selectedUnit.y;
                
                let direction = null;
                if (x > oldX) {
                    direction = 'right';
                } else if (x < oldX) {
                    direction = 'left';
                } else if (y > oldY) {
                    direction = 'down';
                } else if (y < oldY) {
                    direction = 'up';
                }
                
                gameState.lastMoveDirection = direction;
                
                if (gameState.selectedUnit.id === 'player2') {
                    gameState.gundamBetaLastDirection = direction;
                }
                
                gameState.selectedUnit.x = x;
                gameState.selectedUnit.y = y;
                addLog(`${gameState.selectedUnit.name} s'est dÃ©placÃ© en (${x}, ${y})`);
                renderMap();
                updateUI();
            }
        }

        function moveUnit() {
            addLog('Cliquez sur une case verte pour vous dÃ©placer', 'info');
        }

        function attackMode() {
            if (!gameState.selectedUnit || gameState.selectedUnit.acted) return;

            const attackable = getAttackableTiles(gameState.selectedUnit);
            const enemy = gameState.units.find(u =>
                u.team !== gameState.selectedUnit.team &&
                u.isAlive() &&
                attackable.some(a => a.x === u.x && a.y === u.y)
            );

            if (enemy) {
                performAttack(gameState.selectedUnit, enemy);
                gameState.selectedUnit.moved = true;
                gameState.selectedUnit.acted = true;
                addLog(`${gameState.selectedUnit.name} a attaquÃ©`);
                updateUI();
                renderMap();
            } else {
                addLog('Aucun ennemi Ã  proximitÃ©!', 'info');
            }
        }

        function skipAction() {
            if (gameState.selectedUnit) {
                gameState.selectedUnit.moved = true;
                gameState.selectedUnit.acted = true;
                addLog(`${gameState.selectedUnit.name} passe son action`);
                renderMap();
                updateUI();
            }
        }

        function selectNextUnit() {
            const playerUnits = gameState.units.filter(u => u.team === 'player' && u.isAlive());
            if (playerUnits.length === 0) return;

            const currentIndex = gameState.selectedUnit ? playerUnits.findIndex(u => u.id === gameState.selectedUnit.id) : -1;
            const nextIndex = (currentIndex + 1) % playerUnits.length;
            
            gameState.selectedUnit = playerUnits[nextIndex];
            renderMap();
            updateUI();
        }

        function performAttack(attacker, defender) {
            const baseDamage = attacker.stats.atk - Math.floor(defender.stats.def / 2);
            const variance = Math.floor(Math.random() * 5) - 2;
            const damage = Math.max(1, baseDamage + variance);

            const hitChance = Math.max(20, 80 - (Math.abs(defender.stats.spd - attacker.stats.spd) * 2));
            const hit = Math.random() * 100 < hitChance;

            if (hit) {
                defender.takeDamage(damage);
                addLog(`${attacker.name} frappe ${defender.name} pour ${damage} dÃ©gÃ¢ts!`, 'damage');

                if (!defender.isAlive()) {
                    addLog(`${defender.name} est vaincu!`, 'info');
                    checkGameEnd();
                }
            } else {
                addLog(`${attacker.name} manque son attaque!`, 'info');
            }
        }

        function endPlayerTurn() {
            const playerUnits = gameState.units.filter(u => u.team === 'player' && u.isAlive());
            const notFinished = playerUnits.filter(u => !(u.moved && u.acted));

            if (notFinished.length > 0) {
                const names = notFinished.map(u => u.name).join(', ');
                addLog(`${names} n'ont pas fini leur tour!`, 'info');
                return;
            }

            gameState.currentTeam = 'enemy';
            gameState.selectedUnit = null;
            gameState.lastMoveDirection = null;
            updateUI();
            renderMap();
            addLog('--- TOUR ENNEMI ---', 'enemy');

            setTimeout(() => {
                executeEnemyTurns();
            }, 800);
        }

        function executeEnemyTurns() {
            const enemies = gameState.units.filter(u => u.team === 'enemy' && u.isAlive());
            const nextEnemy = enemies.find(e => !e.moved || !e.acted);

            if (!nextEnemy) {
                endEnemyTurn();
                return;
            }

            const players = gameState.units.filter(u => u.team === 'player' && u.isAlive());
            if (players.length === 0) {
                checkGameEnd();
                return;
            }

            if (!nextEnemy.moved) {
                executeEnemyMove(nextEnemy, players);
            } else if (!nextEnemy.acted) {
                executeEnemyAttack(nextEnemy, players);
            }

            renderMap();
            updateUI();

            setTimeout(() => {
                checkGameEnd();
                executeEnemyTurns();
            }, 1200);
        }

        function executeEnemyMove(enemy, players) {
            const target = findBestTarget(enemy, players);
            if (!target) {
                enemy.moved = true;
                return;
            }

            const distance = Math.abs(enemy.x - target.x) + Math.abs(enemy.y - target.y);

            if (distance === 1) {
                enemy.moved = true;
                addLog(`${enemy.name} s'arrÃªte pour attaquer`, 'enemy');
            } else {
                moveEnemyTowardsTarget(enemy, target);
                addLog(`${enemy.name} se rapproche de ${target.name}`, 'enemy');
            }
        }

        function executeEnemyAttack(enemy, players) {
            const target = findBestTarget(enemy, players);
            if (!target) {
                enemy.acted = true;
                return;
            }

            const distance = Math.abs(enemy.x - target.x) + Math.abs(enemy.y - target.y);

            if (distance === 1) {
                performAttack(enemy, target);
                addLog(`${enemy.name} attaque!`, 'enemy');
                enemy.acted = true;
            } else {
                addLog(`${enemy.name} ne peut pas attaquer`, 'enemy');
                enemy.acted = true;
            }
        }

        function findBestTarget(enemy, players) {
            if (players.length === 0) return null;

            let bestTarget = players[0];
            let bestScore = calculateTargetScore(enemy, bestTarget);

            for (let i = 1; i < players.length; i++) {
                const score = calculateTargetScore(enemy, players[i]);
                if (score > bestScore) {
                    bestScore = score;
                    bestTarget = players[i];
                }
            }

            return bestTarget;
        }

        function calculateTargetScore(enemy, target) {
            const distance = Math.abs(enemy.x - target.x) + Math.abs(enemy.y - target.y);
            const healthRatio = target.hp / target.stats.maxHp;
            const damageToTarget = Math.max(1, enemy.stats.atk - Math.floor(target.stats.def / 2));

            let score = 0;
            score -= distance * 3;
            score -= healthRatio * 15;
            score += damageToTarget * 0.5;

            return score;
        }

        function moveEnemyTowardsTarget(enemy, target) {
            const moves = [];

            if (target.x < enemy.x) {
                moves.push(() => moveEnemyLeft(enemy));
            } else if (target.x > enemy.x) {
                moves.push(() => moveEnemyRight(enemy));
            }

            if (target.y < enemy.y) {
                moves.push(() => moveEnemyUp(enemy));
            } else if (target.y > enemy.y) {
                moves.push(() => moveEnemyDown(enemy));
            }

            for (let move of moves) {
                if (move()) break;
            }

            enemy.moved = true;
        }

        function moveEnemyUp(enemy) {
            if (enemy.y > 0 && !gameState.units.some(u => u.x === enemy.x && u.y === enemy.y - 1 && u.isAlive())) {
                enemy.y--;
                return true;
            }
            return false;
        }

        function moveEnemyDown(enemy) {
            if (enemy.y < GRID_HEIGHT - 1 && !gameState.units.some(u => u.x === enemy.x && u.y === enemy.y + 1 && u.isAlive())) {
                enemy.y++;
                return true;
            }
            return false;
        }

        function moveEnemyLeft(enemy) {
            if (enemy.x > 0 && !gameState.units.some(u => u.x === enemy.x - 1 && u.y === enemy.y && u.isAlive())) {
                enemy.x--;
                return true;
            }
            return false;
        }

        function moveEnemyRight(enemy) {
            if (enemy.x < GRID_WIDTH - 1 && !gameState.units.some(u => u.x === enemy.x + 1 && u.y === enemy.y && u.isAlive())) {
                enemy.x++;
                return true;
            }
            return false;
        }

        function endEnemyTurn() {
            gameState.turn++;
            gameState.currentTeam = 'player';
            gameState.units.forEach(u => u.resetTurn());
            gameState.selectedUnit = gameState.units.find(u => u.team === 'player' && u.isAlive());
            gameState.lastMoveDirection = null;
            
            addLog(`--- TOUR ${gameState.turn} JOUEUR ---`, 'info');
            updateUI();
            renderMap();
        }

        function checkGameEnd() {
            gameState.units = gameState.units.filter(u => u.isAlive());
            const playerUnits = gameState.units.filter(u => u.team === 'player');
            const enemyUnits = gameState.units.filter(u => u.team === 'enemy');

            if (playerUnits.length === 0) {
                gameState.gameEnded = true;
                document.getElementById('gameOverTitle').textContent = 'DÃ‰FAITE';
                document.getElementById('gameOverMsg').textContent = 'Tous vos personnages ont Ã©tÃ© vaincus...';
                document.getElementById('gameOver').style.display = 'block';
            } else if (enemyUnits.length === 0) {
                gameState.gameEnded = true;
                document.getElementById('gameOverTitle').textContent = 'VICTOIRE';
                document.getElementById('gameOverMsg').textContent = 'Vous avez vaincu tous les Zakus!';
                document.getElementById('gameOver').style.display = 'block';
            }
        }

        function addLog(message, type = 'info') {
            gameState.battleLog.push({ message, type });
            const logDiv = document.getElementById('battleLog');
            const entry = document.createElement('div');
            entry.className = `logEntry ${type}`;
            entry.textContent = message;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;

            if (gameState.battleLog.length > 100) {
                gameState.battleLog.shift();
                logDiv.removeChild(logDiv.firstChild);
            }
        }
    </script>
</body>
</html>
